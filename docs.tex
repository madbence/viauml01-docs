\documentclass[11pt]{article}

\usepackage{xltxtra}
\usepackage{graphicx}
\usepackage{setspace}
\usepackage{minted}
\usepackage{hyperref}
\usepackage[magyar]{babel}

\hypersetup{
  bookmarks=true,
  unicode=true,
  pdftitle={Node.js backend multiplayer játékhoz},
  pdfauthor={Dányi Bence},
  pdfcreator={Dányi Bence},
  pdfproducer={XeLaTeX},
  pdfkeywords={node.js, websocket, redux, canvas, flowtype, babel},
  pdfnewwindow=true,
  colorlinks=true,
  linkcolor=black,
  citecolor=black,
  filecolor=black,
  urlcolor=black
}

\newminted[js]{javascript}{fontsize=\footnotesize}

\setlength{\parindent}{0pt}
\setlength{\parskip}{8pt plus 3pt minus 3pt}
\onehalfspacing

\begin{document}
\begin{titlepage}
  \begin{center}
    \includegraphics[width=0.5\textwidth]{figures/logo}~\\[1cm]
    \textsc{Budapesti Műszaki és Gazdaságtudományi Egyetem}
    \\[1.5cm]
    \textsc{\Large Önálló Laboratórium 2.}
    \\[1cm]
    { \huge \bfseries Node.js backend multiplayer játékhoz }
    \\[2cm]

    \noindent
    \begin{minipage}[t]{0.4\textwidth}
      \begin{flushleft}
        \large
        \emph{Készítette:}\\
        \textsc{Dányi} Bence
    \end{flushleft}
    \end{minipage}%
    \begin{minipage}[t]{0.4\textwidth}
      \begin{flushright}
        \large
        \emph{Konzulens:} \\
        \textsc{Imre} Gábor
      \end{flushright}
    \end{minipage}

    \vfill

    {\large \today}
  \end{center}
\end{titlepage}
\section{A feladat}

A félév során elvégzendő feladat egy több szereplős játék elkészítése volt,
mely során az én feladatom a játék logikájának megtervezése és implementálása,
valamint a kliens és a szerver közötti kommunikáció megvalósítása volt.

A játékban a játékosok egy űrhajót irányítanak a billentyűzet segítségével,
amivel az űrhajó hajtóműveit tudják ki és bekapcsolni.
A játék célja a többi játékos kiiktatása, ezt az űrhajóra szerelt fegyverekkel
lehet megtenni.

\section{Felhasznált techonlógiák}

Az elkészült alkalmazás ES2015 nyelven készült el, ez a JavaScript 2015 nyarán
szabványosított változata. A szerver NodeJS környezetben fut, így a kliens és
a szerver nagy arányban használja ugyanazt a kódot.

A kliens-szerver kommunikáció Websocket technológián alapul.
Számos absztrakció létezik a kommunikáció részleteinek elfedésére (EngineIO, Primus),
én azonban az overhead elkerülése végett ezeket nem használtam, pusztán
a natív Websocket API-ra.

A szerver oldali kiszolgálás a koa webszerver végzi, ami a népszerű express
szerver következő generációs verziója. A modul API-ja könnyen olvasható,
a kiszolgálásért ún. middleware-ek felelősek. Ezek aszinkron módon működnek,
amit a koa egy generátor alapú megoldással tesz kényelmessé.
Hagyományosan a nyelvben az aszinkron műveletek eredménye (vagy sikertelensége)
egy ún. callback függvényben kezelhető le (hasonlóan a Java/C\#-ban ismert eseménykezelőkhöz),
ezt egyszerűsíti le a generátor alapú szintaxis, ami a C\#-ban meglévő async/await
konstrukciónak felel meg. Jó hír, hogy a nyelv következő változata (ES2016) már
tartalmazni fog egy hasonló konstrukciót.
Mivel az alkalmazás kódját a Babel transpiler fordítja le futtatható JavaScript
kódra, így ez a kényelmes konstrukció már elérhető volt számomra is.

\subsection{Babel}

A Babel (korábban 6to5) egy ún. transpiler, azaz olyan compiler, amiben a forrás
és a célnyelv ugyanaz. A feladata a böngészők (illetve a NodeJS futtatókörnyezet)
által még nem futtatható JavaScript kód (ES2015) transzformálása egy korábbi,
általánosan elérhető dialektusra (ES5).

Mivel az alkalmazás moduláris felépítésű, így szükség van az elkészült állományok
összecsomagolására, ez a böngésző számára a hatékonyabb betöltés miatt szükséges.
Ezt könnyíti meg a browserify csomag, ami a forrásfájlokból egyetlen, a kliens
által futtatható bundle-t csinál.
Fejlesztés közben a teljes fordítás sajnos nagyon lassú (ahogy minden más nyelvben),
így a folyamat felgyorsítására a watchify csomagot használtam, ami inkrementális
fordítást biztosít, illetve folyamatosan figyeli a forrásfájlokat,
így a fordítás automatikus.

\subsection{Flowtype}

A JavaScript nyelv egyik nagy hátrányának a statikus típusosság hiányát tartják.
Erre nyújt megoldás a Facebook techonlógiája, a Flowtype, mely a nyelvet
új nyelvi elemekkel (típusannotációkkal) egészíti ki, és lehetőséget ad a program
típushelyességének bizonyítására, mindezt a fordítási folyamat részeként.

A típusellenőrzés opcionális, a @flow direktívával engedélyezhető, így alkalmas
fokozatos bevezetésre már meglévő projectekben is.
A fordító fejlett, képes az egyes típusok kikövetkeztetésére, így elegendő
a függvény szignatúráját (valójában elég csak a modulból kiexportált függvények
szignatúráját) annotálni, a többi típus kikövetkeztethető (inferring).

\subsection{redux}

A redux egy állapot-konténer melynek segítségével a fejlesztő egyszerűen képes
az alkalmazás állapotát egy egységes API-n keresztül módosítani.
A felhasználó akciókat süt el, melynek hatására a felület frissül.
Az akciók egyszerű Javascript objektumok, egy kötelező type tulajdonsággal,
egy opcionális payload és egy szintén opcionális meta propertyvel ellátva.

A type az akció típusát tartalmazza, erre azért van szükség, hogy a sorosítás
során (amire a Websocket kapcsolat miatt van szükség) ne vesszen el
típusinformáció.
A payload az akcióhoz kapcsolódó adatokat (paramétereket) tartalmazza,
ha van ilyen, akkor az tipikusan egy hagyományos JavaScript objektum (de
természetesen tetszőleges primitív típus is lehet).
A meta az akcióhoz szorosan nem kapcsolódó információkat tartalmazza, tipikusan
szintén egy JavaScript objektum.
Az alkalmazásban a szerverre felküldendő akciók pending: true propertyvel
váltódnak ki, így azok nem közvetlenül a kliensen hajtódnak végre, hanem
Websocket kapcsolaton keresztül a szerveren futnak le (ami tipukusan visszaküldi az
akciót már a pending property nélkül).

\section{Az elkészült alkalmazás}

\begin{figure}[h!]
  \centering
  \includegraphics[width=\textwidth]{figures/ws}
  \caption{A Websocket alapú kommunikáció architektúrája}
  \label{fig:ws-arch}
\end{figure}

\begin{js}
  const comp = (f, g) => ((s, a) => g(f(s, a), a));
  const reduce = comp(
    (state, action) => {
      while (state.time < action.time) {
        state = evolve(state, dt);
      }
      return state;
    },

    (state, action) => {
      return handleUserInput(state, action);
    }
  );
\end{js}

\begin{js}
  const netTorqe = object.forces.reduce(
    (torqe, f) => torqe + cross(f.position, unit(f.orientation)) * f.strength,
    0
  );
\end{js}

\begin{js}
  const netForce = object.forces.reduce(
    (force, f) => add(force, f),
    { x: 0, y: 0 }
  );
\end{js}

\subsection{Perzisztens adatstruktúrák}

Az alkalmazás kliens oldali részének állapotát egy egyszerű objektum-gráf
reprezentálja, a kiváltott akciók ezt az állapotot befolyásolják.
Azoban az állapot közvetlenül nem módosítható, minden akció egy teljesen
új állapotot eredményez. Ez nem jelenti azt, hogy minden egyes akció lekezelésekor
le kellene másolni a meglévő állapot, annak pusztán a megváltozott részét szükséges
legyártani, a többi részét a gráfnak hivatkozni lehet (hiszen az nem változhat meg később sem).

Ez azt eredményezi, hogy az alkalmazás állapota könnyen elmenthető és visszaállítható
tetszőleges pontra. Mivel a gráf minden eleme egy egyszerű JavaScript objektum,
így az állapot sorosítható is (akár localStorage-ba is, így bezárás után is képes megtartani az állapotát).

\section{Továbbfejlesztési lehetőségek}

A játék grafikája jelenleg nagyon sematikus, ezen rengeteg dolog javítható,
egy érdekes feladat lenne valamilyen WebGL-es megoldással 3 dimenziós grafikát
adni hozzá.

A játék irányítása sajnos nem túl intuitív, a hajtóművek szabályozása nagyon
nehéz. Ez egy teljesen szándékos döntés, a későbbiekben szeretnék implementálni
egy scriptelési réteget a vezérlés fölé, azaz a játékosok az űrhajó API-ját
felhasználva egy teljesen testreszabható szabályozási rendszert építhet fölé
(akár intuitívabb vezérlést, de akár egy komplett mesterséges intelligenciát).
Később a játékosok akár meg is tudnák ezeket a vezérlőket osztani egymással.

\end{document}
